好的，这是对“工作流引擎 (Workflow)”模块设计的中文翻译：

**工作流引擎 (Workflow) 模块设计**

**核心概念:**

1.  **工作流定义 (Workflow Definition):** 流程的蓝图或模板，使用可视化设计器创建。它由节点（步骤）和转换（连接线）以及相关的规则和配置组成。持久化存储（例如，作为 JSON 存储在数据库中）。
2.  **工作流实例 (Workflow Instance):** 工作流定义的特定、正在运行的执行过程，由事件触发（例如，提交请假申请）。每个实例都有自己的状态（当前活动节点、数据负载、历史记录）。
3.  **工作流节点 (Workflow Node):** 代表流程中的单个工作单元或逻辑（例如，开始、结束、用户任务/审批、服务任务/自动操作、决策网关/判断节点、通知）。
4.  **转换/连接线 (Transition/Connection):** 定义节点之间的路径。可以基于工作流实例数据设置条件。
5.  **任务 (Task):** 作为工作流实例一部分分配给用户或角色的工作单元（例如，一个审批步骤会为经理生成一个任务）。

**I. 前端组件 (工作流设计器)**

1.  **WorkflowDesignerPage (新的页面组件)**
    *   **功能:** 提供创建、查看和编辑工作流定义的主要界面。编排设计器 UI 组件。获取可用的节点类型和现有的定义。处理保存新的/更新的定义。
    *   **包含:** `WorkflowCanvas` (工作流画布), `NodePalette` (节点面板), `PropertiesPanel` (属性面板)。
    *   **关系:** 在 `AppLayout` -> `PageContainer` 内渲染，可能通过特定的管理员/开发者导航访问。与 `/api/workflows/definitions` 以及可能与 `/api/workflows/designer/config` API 交互。

2.  **NodePalette (可重用 UI 组件)**
    *   **功能:** 显示可拖拽到画布上的可用节点类型列表。
    *   **Props:** `nodeTypes` (可用节点定义的数组，例如 `{ type: 'approval', label: '审批节点', icon: '...', default_config: {...} }`)。
    *   **交互:** 使用拖放 (Drag-and-Drop) API 允许用户将节点拖到 `WorkflowCanvas` 上。

3.  **WorkflowCanvas (核心设计器组件)**
    *   **功能:** 构建工作流图的主要交互区域。渲染节点和连接线。处理节点拖动、连接线绘制、节点选择。
    *   **技术:** 可能会使用专门的库，如 **`React Flow`** (推荐) 或 `JointJS`, `GoJS` (商业库) 等。
    *   **Props:** `initialElements` (为现有定义加载的节点和边), `onElementsChange` (当图表更改时的回调), `onNodeSelect` (当节点被点击时的回调)。
    *   **包含:** 根据数据渲染不同节点类型的可视化表示。
    *   **交互:** 将更改反馈给 `WorkflowDesignerPage`。在节点/边被选中时触发 `PropertiesPanel` 的显示。

4.  **PropertiesPanel (可重用 UI 组件)**
    *   **功能:** 显示 `WorkflowCanvas` 上当前选定节点或连接线的配置选项。内容根据选择动态更改。
    *   **配置示例:**
        *   **审批节点:** 指派人 (基于规则: 'RequesterManager' [申请人经理], 基于角色: 'HR Manager' [人事经理], 特定用户), 审批类型 ('Sequential' [顺序审批], 'Parallel/Countersign' [并行/会签]), 超时 (时长, 超时动作: 'Remind' [提醒], 'AutoApprove' [自动批准], 'AutoReject' [自动驳回], 'Escalate' [上报])。
        *   **决策节点 (判断节点):** 配置传出转换的条件 (例如, `leave_days <= 3`, `leave_type == 'sick'`)。使用来自工作流数据负载 (payload) 中的字段。
        *   **通知节点:** 接收人, 消息模板 (可以使用来自数据负载的变量)。
        *   **表单节点:** 使用哪个 `DynamicForm` 定义 (链接到表单配置)。
        *   **连接线:** 条件 (如果来自决策节点)。
    *   **Props:** `selectedElement` (节点或边的对象), `onChange` (更新元素配置数据的回调)。
    *   **包含:** 根据 `selectedElement` 的类型及其可配置属性，动态渲染合适的表单字段。

**II. 后端组件 (工作流引擎核心)**

1.  **工作流定义服务 (Workflow Definition Service):**
    *   **功能:** 管理工作流定义的存储和检索 (增删改查 CRUD 操作)。验证定义结构。处理版本控制。
    *   **存储:** 存储工作流定义的数据库表 (例如, `workflow_definitions` 表，包含 `id`, `name`, `description`, `definition_json`, `version`, `created_at`, `updated_at` 列)。`definition_json` 包含来自前端设计器的序列化图数据。

2.  **工作流实例服务 (Workflow Instance Service):**
    *   **功能:** 管理运行中工作流实例的生命周期。启动新实例，持久化其状态，检索实例详情和历史记录。
    *   **存储:** 存储实例状态的数据库表 (例如, `workflow_instances` 表，包含 `id`, `definition_id`, `definition_version`, `status` ('RUNNING', 'COMPLETED', 'FAILED', 'SUSPENDED'), `current_node_ids` (如果是并行则为 JSON 数组), `payload` (存储实例数据的 JSON，如请假请求详情), `start_time`, `end_time` 列)。

3.  **工作流执行引擎 (Workflow Execution Engine - 核心逻辑):**
    *   **功能:** 引擎的核心。接收一个工作流实例及其定义，确定当前活动节点，执行节点的逻辑，并根据转换和条件确定下一个节点。这是事件驱动或基于状态机的。
    *   **步骤:**
        *   接收触发器 (例如, "启动工作流", "任务完成")。
        *   加载实例状态和定义。
        *   识别当前节点。
        *   执行节点逻辑:
            *   **开始节点:** 初始化数据负载 (payload)，移动到下一个节点。
            *   **结束节点:** 将实例标记为 'COMPLETED'。
            *   **用户任务 (审批/表单):** 通过任务服务创建一个任务，暂停此路径的执行，直到任务完成。
            *   **决策网关 (判断节点):** 使用实例的 `payload` 评估传出转换上的条件。选择合适的路径。
            *   **服务任务 (自动化):** 执行后端代码 (例如, 调用外部 API, 更新数据库记录)。可以是可插拔的。
            *   **通知任务:** 将数据发送到通知服务。
        *   根据成功执行和有效的转换确定下一个节点。
        *   更新实例状态 (当前节点, 可能还有 payload)。
        *   持久化更改。
        *   如果下一个节点是自动化的，立即触发其执行。

4.  **任务服务 (Task Service):**
    *   **功能:** 管理由工作流引擎生成的用户任务。分配任务，跟踪状态 (待处理, 进行中, 已完成, 已取消)，处理完成事件。
    *   **存储:** 任务的数据库表 (例如, `workflow_tasks` 表，包含 `id`, `instance_id`, `node_id`, `task_type` ('APPROVAL', 'FORM_ENTRY'), `assignee_type` ('USER', 'ROLE'), `assignee_id`, `status`, `due_date`, `payload` (任务特定数据), `outcome` (完成时的结果), `created_at`, `completed_at` 列)。
    *   **集成:** 需要访问用户目录/组织结构服务来解析指派人 ('RequesterManager' [申请人经理], 角色成员)。

5.  **规则引擎 / 条件评估器 (Rule Engine / Condition Evaluator):**
    *   **功能:** 解析和评估定义在转换上的条件 (特别是来自决策网关的)。需要访问工作流实例的 `payload`。
    *   **实现:** 可以从简单的表达式评估 (例如, 在 Node.js 中使用像 `expr-eval` 这样的库) 到集成更强大的专用规则引擎。

6.  **定时器 / 调度服务 (Timer/Scheduler Service):**
    *   **功能:** 管理节点上配置的超时 (例如, 审批任务)。在截止日期到达时触发事件 (例如, 发送提醒, 执行超时操作)。
    *   **实现:** 需要一个持久化的调度机制 (例如, 定时任务轮询到期任务, 具有延迟传递的消息队列, Redis 排序集)。

**III. API 端点 (新的 / 修改的)**

1.  **工作流定义 (`/api/workflows/definitions`)**
    *   `POST /`: 创建/保存一个新的定义 (Payload: 设计器的 JSON 数据)。
    *   `GET /`: 列出可用的定义。
    *   `GET /{definitionId}`: 获取特定定义的详细信息 (用于在设计器中加载)。
    *   `PUT /{definitionId}`: 更新一个现有的定义。
    *   `DELETE /{definitionId}`: 删除一个定义。

2.  **工作流实例 (`/api/workflows/instances`)**
    *   `POST /`: 启动一个新的工作流实例 (Payload: `{ definitionId: 'leave_approval_v1', initialPayload: { /* 请假请求数据 */ } }`)。返回新的 `instanceId`。 **(由后端在请假请求成功提交后触发)**。
    *   `GET /`: 列出实例 (按状态、定义等过滤)。
    *   `GET /{instanceId}`: 获取特定实例的状态、历史记录和数据负载 (payload)。
    *   `GET /{instanceId}/history`: (可选的特定端点) 获取详细的步骤历史记录。

3.  **工作流任务 (`/api/workflows/tasks`)**
    *   `GET /?assignee=me&status=pending`: **(替换/补充 `GET /api/leave-requests/pending`)** 获取分配给当前用户的任务。响应包括任务详情和可能关联的数据摘要 (例如来自实例 payload 的请假请求信息)。
    *   `GET /{taskId}`: 获取特定任务的完整详细信息，包括其 payload 和关联的工作流实例信息。
    *   `POST /{taskId}/complete`: **(替换 `PATCH /api/leave-requests/{id}/approve|reject`)** 用户完成一个任务 (例如, 提交批准/驳回)。Payload: `{ outcome: 'approved', comment: 'OK', data: { /* 可选的表单数据 */ } }`。这将触发后端引擎处理完成事件。
    *   `POST /{taskId}/claim`: (可选) 如果任务分配给一个角色，允许该角色中的用户认领它。
    *   `POST /{taskId}/update`: (可选) 保存表单任务的部分进度。

4.  **工作流设计器配置 (`/api/workflows/designer/config`)** (可选)
    *   `GET /`: 为设计器 UI 提供元数据 (可用的节点类型, 每种类型的配置模式, 图标等)。

5.  **用户/组织结构集成 (`/api/users`, `/api/orgchart`)** (假设已存在或新建)
    *   任务服务/引擎需要用来解析指派人 (例如, `GET /api/users/{userId}/manager`, `GET /api/roles/{roleName}/members`)。

**IV. 与现有应用的集成**

1.  **请假申请提交:** 在 `POST /api/leave-requests` 成功后，后端控制器/服务现在还应该调用 `POST /api/workflows/instances` 来启动相应的工作流 (识别正确的定义，可能基于请假类型或天数，或一个默认流程)。请假请求的 ID 和数据成为初始的 `payload`。
2.  **待处理审批页面 (`MyRequestsPage` / `PendingApprovalsPage`):** 现在应主要查询 `GET /api/workflows/tasks?assignee=me&status=pending`。`DataTable` 将显示任务。点击任务行仍应导航到详情视图。
3.  **请假申请详情页面 (`LeaveRequestDetailPage`):**
    *   可能需要同时获取原始请假请求数据 (`GET /api/leave-requests/{id}`) *和* 关联的工作流实例状态/历史 (`GET /api/workflows/instances/{instanceId}`)。如果从任务列表导航而来，它可能还需要获取*特定任务*的详情 (`GET /api/workflows/tasks/{taskId}`)。
    *   `ActionToolbar` 的按钮 (批准/驳回) 现在将触发 `POST /api/workflows/tasks/{taskId}/complete` 并带有适当的结果 (outcome)。`taskId` 需要对该组件可用。
    *   `StatusIndicator` 可能显示*任务*状态或整体*工作流实例*状态。
    *   `WorkflowHistory` 组件变得更加重要，可能从 `GET /api/workflows/instances/{instanceId}/history` 获取数据。
4.  **数据同步:** 工作流引擎需要一种机制，在工作流达到某些点时（例如，最终批准/驳回、取消），更新原始请假记录（在 `leave_requests` 表中）的状态。这可以通过工作流定义内的服务任务或引擎完成逻辑中的钩子 (hooks) 来完成。

**V. 关键考虑因素:**

*   **技术选型 (后端):** Java (Camunda, Flowable), .NET (CoreWF), Python (SpiffWorkflow), 或 Node.js (自定义引擎或库) 都是选项。使用专门的工作流引擎可能比从头构建更健壮。
*   **技术选型 (前端):** `React Flow` 是可视化设计器画布的有力竞争者。
*   **复杂性:** 构建一个健壮的、可视化的工作流引擎是一项重大的任务。从核心功能（线性审批、简单条件）开始，然后迭代。
*   **版本控制:** 对于已经在运行的实例，如何处理工作流定义的更改？（常见策略：在旧版本上完成、迁移或终止）。
*   **错误处理与弹性:** 如果自动化任务失败会怎样？如何呈现错误？如何重试或手动纠正工作流？
*   **权限:** 谁可以设计工作流？谁可以查看实例数据？谁可以管理/取消运行中的实例？

这个设计为集成到您的低代码平台中的可视化工作流引擎提供了所需的组件和交互的全面概述。