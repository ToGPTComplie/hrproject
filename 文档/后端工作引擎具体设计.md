好的，这是将之前提供的 Django 后端设计中的注释、提示和部分字符串翻译成中文后的版本。

**I. Django 模型 (`models.py`)**

```python
# workflows/models.py
from django.db import models
from django.conf import settings
# from django.contrib.auth.models import User # 使用 settings.AUTH_USER_MODEL 代替
from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.models import ContentType
from django.utils.translation import gettext_lazy as _ # 用于模型字段的国际化
import uuid

# --- 工作流定义 ---
class WorkflowDefinition(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=255, unique=True, help_text=_("工作流定义的唯一名称"))
    description = models.TextField(blank=True, null=True, verbose_name=_("描述"))
    # 存储来自前端设计器的图形结构 (节点、边、位置)
    definition_json = models.JSONField(help_text=_("工作流图的 JSON 表示"))
    version = models.PositiveIntegerField(default=1, verbose_name=_("版本"))
    is_active = models.BooleanField(default=True, help_text=_("此定义是否可用于启动新实例"))
    created_at = models.DateTimeField(auto_now_add=True, verbose_name=_("创建时间"))
    updated_at = models.DateTimeField(auto_now=True, verbose_name=_("更新时间"))

    class Meta:
        verbose_name = _("工作流定义")
        verbose_name_plural = _("工作流定义")
        unique_together = ('name', 'version') # 允许同名工作流有多个版本
        ordering = ('name', '-version')

    def __str__(self):
        return f"{self.name} (v{self.version})"

# --- 工作流实例 ---
class WorkflowInstance(models.Model):
    class Status(models.TextChoices):
        PENDING = 'PENDING', _('待处理') # 实例已创建但尚未开始执行第一个节点
        RUNNING = 'RUNNING', _('运行中')
        COMPLETED = 'COMPLETED', _('已完成')
        FAILED = 'FAILED', _('失败')
        CANCELED = 'CANCELED', _('已取消')
        SUSPENDED = 'SUSPENDED', _('已暂停') # 用于手动干预或长时间等待

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    definition = models.ForeignKey(WorkflowDefinition, on_delete=models.PROTECT, related_name='instances', verbose_name=_("关联定义"))
    status = models.CharField(max_length=20, choices=Status.choices, default=Status.PENDING, verbose_name=_("状态"))
    # 存储与此特定运行关联的动态数据 (例如，请假请求详情)
    payload = models.JSONField(default=dict, help_text=_("此工作流实例的数据负载"), verbose_name=_("数据负载"))
    # 存储 definition_json 中当前活动节点的 ID 列表
    # 如果工作流具有并行路径，则可以是列表
    current_node_ids = models.JSONField(default=list, help_text=_("定义中活动节点的 ID 列表"), verbose_name=_("当前节点ID"))
    started_at = models.DateTimeField(auto_now_add=True, verbose_name=_("开始时间"))
    completed_at = models.DateTimeField(null=True, blank=True, verbose_name=_("完成时间"))
    # 可选：链接到触发此工作流的对象 (例如，一个 LeaveRequest)
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE, null=True, blank=True, verbose_name=_("触发对象类型"))
    object_id = models.UUIDField(null=True, blank=True, verbose_name=_("触发对象ID")) # 假设关联对象的主键是 UUID
    triggered_by_object = GenericForeignKey('content_type', 'object_id')

    class Meta:
        verbose_name = _("工作流实例")
        verbose_name_plural = _("工作流实例")
        ordering = ('-started_at',)

    def __str__(self):
        return f"实例 {self.id} ({self.definition.name} v{self.definition.version}) - {self.get_status_display()}"

# --- 工作流任务 (用户任务，如审批) ---
class WorkflowTask(models.Model):
    class Status(models.TextChoices):
        PENDING = 'PENDING', _('待处理') # 任务已创建，等待分配或认领
        ASSIGNED = 'ASSIGNED', _('已分配') # 任务已被认领或直接分配给特定用户
        COMPLETED = 'COMPLETED', _('已完成')
        CANCELED = 'CANCELED', _('已取消') # 工作流路径改变，任务不再需要

    class AssigneeType(models.TextChoices):
        USER = 'USER', _('特定用户')
        ROLE = 'ROLE', _('角色/用户组')
        RULE = 'RULE', _('规则指定') # 例如, 'RequesterManager' (申请人经理)

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    instance = models.ForeignKey(WorkflowInstance, on_delete=models.CASCADE, related_name='tasks', verbose_name=_("关联实例"))
    # 生成此任务的 definition_json 中的节点 ID
    node_id = models.CharField(max_length=255, help_text=_("来自工作流定义的节点 ID"), verbose_name=_("节点 ID"))
    task_type = models.CharField(max_length=50, default='APPROVAL', help_text=_("任务类型，例如 APPROVAL, FORM_ENTRY"), verbose_name=_("任务类型"))
    status = models.CharField(max_length=20, choices=Status.choices, default=Status.PENDING, verbose_name=_("状态"))

    # 指派人信息
    assignee_type = models.CharField(max_length=20, choices=AssigneeType.choices, verbose_name=_("指派类型"))
    # 根据 assignee_type 存储用户 ID、角色名称或规则标识符
    assignee_identifier = models.CharField(max_length=255, help_text=_("用户 ID、角色名称或规则标识符"), verbose_name=_("指派标识"))
    # 可选：一旦分配/认领，链接到实际用户 (对于 ROLE 类型特别有用)
    assigned_users = models.ManyToManyField(settings.AUTH_USER_MODEL, blank=True, related_name='workflow_tasks', verbose_name=_("已分配用户"))

    # 任务元数据
    due_date = models.DateTimeField(null=True, blank=True, verbose_name=_("截止日期"))
    # 存储任务完成的结果，例如 'approved', 'rejected', 自定义结果
    outcome = models.CharField(max_length=100, null=True, blank=True, verbose_name=_("结果"))
    # 存储任务完成时提交的数据 (例如，审批意见，表单数据)
    completion_data = models.JSONField(null=True, blank=True, verbose_name=_("完成数据"))
    created_at = models.DateTimeField(auto_now_add=True, verbose_name=_("创建时间"))
    completed_at = models.DateTimeField(null=True, blank=True, verbose_name=_("完成时间"))
    completed_by = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True, blank=True, related_name='+', verbose_name=_("完成人"))

    class Meta:
        verbose_name = _("工作流任务")
        verbose_name_plural = _("工作流任务")
        ordering = ('created_at',)

    def __str__(self):
        return f"任务 {self.id} (实例 {self.instance.id}, 节点 {self.node_id}) - {self.get_status_display()}"


# --- 工作流历史记录 (可选但推荐用于审计) ---
class WorkflowHistory(models.Model):
    class EventType(models.TextChoices):
        INSTANCE_STARTED = 'INSTANCE_STARTED', _('实例已启动')
        INSTANCE_COMPLETED = 'INSTANCE_COMPLETED', _('实例已完成')
        INSTANCE_FAILED = 'INSTANCE_FAILED', _('实例失败')
        INSTANCE_CANCELED = 'INSTANCE_CANCELED', _('实例已取消')
        NODE_ENTERED = 'NODE_ENTERED', _('进入节点')
        NODE_EXITED = 'NODE_EXITED', _('离开节点') # 通常在移动到下一个节点时
        TASK_CREATED = 'TASK_CREATED', _('任务已创建')
        TASK_ASSIGNED = 'TASK_ASSIGNED', _('任务已分配/认领')
        TASK_COMPLETED = 'TASK_COMPLETED', _('任务已完成')
        TASK_TIMED_OUT = 'TASK_TIMED_OUT', _('任务超时')
        COMMENT_ADDED = 'COMMENT_ADDED', _('评论已添加') # 通用目的评论

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    instance = models.ForeignKey(WorkflowInstance, on_delete=models.CASCADE, related_name='history_logs', verbose_name=_("关联实例"))
    node_id = models.CharField(max_length=255, null=True, blank=True, help_text=_("相关的节点 ID，如果适用"), verbose_name=_("节点 ID"))
    task = models.ForeignKey(WorkflowTask, on_delete=models.SET_NULL, null=True, blank=True, related_name='history_logs', verbose_name=_("关联任务"))
    event_type = models.CharField(max_length=30, choices=EventType.choices, verbose_name=_("事件类型"))
    timestamp = models.DateTimeField(auto_now_add=True, verbose_name=_("时间戳"))
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True, blank=True, help_text=_("触发事件的用户，如果适用"), verbose_name=_("用户"))
    # 存储额外细节，如评论、结果、评估的条件、错误消息
    details = models.JSONField(null=True, blank=True, verbose_name=_("详情"))

    class Meta:
        verbose_name = _("工作流历史")
        verbose_name_plural = _("工作流历史")
        ordering = ('timestamp',)

    def __str__(self):
        return f"{self.timestamp} - {self.instance.id} - {self.get_event_type_display()}"
```

**II. 核心引擎逻辑 (`services.py` 或 `engine.py`)**

```python
# workflows/services.py
from django.utils import timezone
from django.db import transaction
from django.contrib.auth import get_user_model
from django.contrib.contenttypes.models import ContentType
from django.utils.translation import gettext as _ # 用于服务层中的字符串

from .models import WorkflowDefinition, WorkflowInstance, WorkflowTask, WorkflowHistory
# 修正导入路径，确保它们指向你的模型
from .models import WorkflowTask as TaskStatusModel # 重命名以避免与常量冲突
from .models import WorkflowInstance as InstanceStatusModel
from .models import WorkflowTask as AssigneeTypeModel

# 假设用户/角色/组织逻辑可用 (例如，在 'accounts' 应用中)
# from accounts.services import get_user_manager, get_users_in_role

# --- 用户/组织服务的占位符 ---
# 用你实际的用户/角色查找逻辑替换
class OrgChartService:
    def get_user_manager(self, user):
        # 实现查找用户经理的逻辑
        print(f"警告：OrgChartService.get_user_manager 未为用户 {user.id} 实现")
        return None # 占位符

    def get_users_in_role(self, role_name):
        # 实现查找属于某个角色/组的用户的逻辑
        print(f"警告：OrgChartService.get_users_in_role 未为角色 {role_name} 实现")
        User = get_user_model()
        # 示例：return User.objects.filter(groups__name=role_name)
        return [] # 占位符

org_chart_service = OrgChartService() # 实例化或获取服务

# --- 规则评估器 ---
class RuleEvaluator:
    def evaluate(self, condition_string, payload):
        # 警告：评估任意字符串是危险的！
        # 使用安全的评估库 (如 'asteval' 或构建简单的解析器)
        # 为简单起见，这里只做基本检查。请替换为健壮的实现。
        print(f"正在评估条件：'{condition_string}' 使用 payload：{payload}")
        try:
            # 示例简单条件："payload.leave_days <= 3"
            if condition_string is None or condition_string.strip() == '':
                return True # 无条件视为真
            if 'payload.' in condition_string:
                parts = condition_string.split(' ')
                if len(parts) == 3:
                    key = parts[0].replace('payload.', '')
                    op = parts[1]
                    value_str = parts[2]
                    payload_value = payload.get(key)

                    if payload_value is None: return False

                    # 基本比较 (生产环境中需要显著扩展)
                    try:
                        # 尝试数字比较
                        num_payload = float(payload_value)
                        num_value = float(value_str)
                        if op == '<=': return num_payload <= num_value
                        if op == '>': return num_payload > num_value
                        if op == '==': return num_payload == num_value
                        if op == '!=': return num_payload != num_value
                        if op == '<': return num_payload < num_value
                        if op == '>=': return num_payload >= num_value
                    except ValueError:
                         # 如果转换数字失败，尝试字符串比较
                         str_value = value_str.strip("'\"") # 去除引号
                         str_payload = str(payload_value)
                         if op == '==': return str_payload == str_value
                         if op == '!=': return str_payload != str_value
                         # 对字符串的其他比较意义不大，除非有特殊需求

                    # 添加更多操作符和类型检查
            print(f"警告：不支持的条件格式：{condition_string}")
            return False # 条件未知或格式错误时默认为 false
        except Exception as e:
            print(f"错误：评估条件 '{condition_string}' 时出错：{e}")
            return False

rule_evaluator = RuleEvaluator()

# --- 工作流引擎服务 ---
class WorkflowEngineService:

    def _log_history(self, instance, event_type, node_id=None, task=None, user=None, details=None):
        WorkflowHistory.objects.create(
            instance=instance,
            node_id=node_id,
            task=task,
            event_type=event_type,
            user=user,
            details=details or {}
        )

    def _find_node_by_id(self, definition_json, node_id):
        nodes = definition_json.get('nodes', [])
        for node in nodes:
            if node.get('id') == node_id:
                return node
        return None

    def _find_outgoing_edges(self, definition_json, source_node_id):
        edges = definition_json.get('edges', [])
        return [edge for edge in edges if edge.get('source') == source_node_id]

    def _resolve_assignees(self, assignee_type, identifier, instance):
        User = get_user_model()
        users = []
        if assignee_type == AssigneeTypeModel.AssigneeType.USER:
            try:
                # 假设 identifier 是用户 ID
                users.append(User.objects.get(pk=identifier)) # 使用 pk 更通用
            except User.DoesNotExist:
                print(f"错误：指派人用户 ID {identifier} 未找到。")
        elif assignee_type == AssigneeTypeModel.AssigneeType.ROLE:
             # 假设 identifier 是角色名称
            users.extend(org_chart_service.get_users_in_role(identifier))
        elif assignee_type == AssigneeTypeModel.AssigneeType.RULE:
            if identifier == 'RequesterManager':
                 # 假设 payload 中有 'requester_id'
                 requester_id = instance.payload.get('requester_id')
                 if requester_id:
                     try:
                        requester = User.objects.get(pk=requester_id)
                        manager = org_chart_service.get_user_manager(requester)
                        if manager:
                            users.append(manager)
                        else:
                            print(f"警告：用户 {requester_id} 的经理未找到。")
                     except User.DoesNotExist:
                         print(f"错误：申请人用户 ID {requester_id} 未找到。")
                 else:
                     print("错误：无法解析 'RequesterManager'，payload 中缺少 'requester_id'。")
            # 根据需要添加更多规则
        return users

    def _create_task(self, instance, node_definition):
        node_id = node_definition.get('id')
        # 假设配置嵌套在节点数据的 'data' 字段下
        config = node_definition.get('data', {}).get('config', {})
        # 从配置中获取或使用默认值
        assignee_type = config.get('assigneeType', AssigneeTypeModel.AssigneeType.ROLE)
        assignee_identifier = config.get('assigneeIdentifier', 'DefaultRole') # 需要一个有意义的默认值或使其必需

        task = WorkflowTask.objects.create(
            instance=instance,
            node_id=node_id,
            # 使用节点类型或配置中的 taskType
            task_type=config.get('taskType', node_definition.get('type', 'APPROVAL')).upper(),
            status=TaskStatusModel.Status.PENDING,
            assignee_type=assignee_type,
            assignee_identifier=assignee_identifier,
            # due_date= # 如果存在 config.timeoutDuration，则计算得出
        )
        # 可选：如果 assignee_type 是 USER 或 ROLE 分配是立即的，则立即解析并链接用户
        # resolved_users = self._resolve_assignees(assignee_type, assignee_identifier, instance)
        # if resolved_users:
        #     task.assigned_users.set(resolved_users)
        #     task.status = TaskStatusModel.Status.ASSIGNED # 或者保持 PENDING 直到被认领？取决于逻辑。
        #     task.save()

        self._log_history(instance, WorkflowHistory.EventType.TASK_CREATED, node_id=node_id, task=task, details={'指派给': f"{assignee_type}:{assignee_identifier}"})
        # TODO: 向潜在的指派人发送通知
        # TODO: 如果 config.timeoutDuration 存在，使用 Celery 安排超时检查
        return task

    @transaction.atomic
    def start_instance(self, definition_id, initial_payload, triggered_by_object=None, user=None):
        try:
            # 优先选择最新的 active 版本
            definition = WorkflowDefinition.objects.filter(
                # 如果 name 是唯一的，可以直接用 name 查找最新 active 版本
                # name=definition_name,
                id=definition_id, # 如果传入的是特定版本的 ID
                is_active=True
            ).latest('version') # 或者根据你的逻辑选择版本
        except WorkflowDefinition.DoesNotExist:
            print(f"错误：活动的工作流定义 {definition_id} 未找到。")
            # 或者引发异常
            return None

        instance = WorkflowInstance.objects.create(
            definition=definition,
            status=InstanceStatusModel.Status.RUNNING, # 开始时即为运行中
            payload=initial_payload,
            current_node_ids=[], # 将通过查找开始节点来设置
            triggered_by_object=triggered_by_object
        )
        self._log_history(instance, WorkflowHistory.EventType.INSTANCE_STARTED, user=user, details={'初始负载': initial_payload})

        # 查找 'start' 节点 (假设来自 React Flow 的类型是 'startNode')
        start_node = None
        for node in definition.definition_json.get('nodes', []):
             # 根据你的前端开始事件节点类型调整 'startNode'
            if node.get('type') == 'startNode':
                start_node = node
                break

        if not start_node:
            instance.status = InstanceStatusModel.Status.FAILED
            instance.completed_at = timezone.now()
            instance.save()
            self._log_history(instance, WorkflowHistory.EventType.INSTANCE_FAILED, details={'错误': '定义中未找到开始节点'})
            print(f"错误：定义 {definition.id} 未找到开始节点")
            return instance # 返回失败的实例

        # 立即从开始节点推进
        self.advance_workflow(instance, start_node.get('id'))
        return instance

    @transaction.atomic
    def advance_workflow(self, instance, completed_node_id, completion_data=None):
        # completion_data 通常包含任务结果等信息，会合并到实例 payload 中或用于条件判断

        # 重新获取实例以确保状态最新，并锁定行以防并发问题
        try:
            instance = WorkflowInstance.objects.select_for_update().get(pk=instance.pk)
        except WorkflowInstance.DoesNotExist:
            print(f"错误：实例 {instance.pk} 在推进时丢失。")
            return

        if instance.status not in [InstanceStatusModel.Status.RUNNING, InstanceStatusModel.Status.SUSPENDED]:
             print(f"警告：尝试推进非运行中的实例 {instance.id} (状态: {instance.status})")
             return

        definition_json = instance.definition.definition_json
        completed_node = self._find_node_by_id(definition_json, completed_node_id)

        if not completed_node:
            # 如果调用正确，这不应该发生
            print(f"错误：完成的节点 ID {completed_node_id} 在实例 {instance.id} 中未找到")
            # 考虑将实例标记为 FAILED
            instance.status = InstanceStatusModel.Status.FAILED
            instance.save()
            self._log_history(instance, WorkflowHistory.EventType.INSTANCE_FAILED, node_id=completed_node_id, details={'错误': f'完成的节点 {completed_node_id} 在定义中未找到'})
            return

        # 更新 payload（例如合并任务的完成数据）
        if isinstance(completion_data, dict):
            instance.payload.update(completion_data) # 合并结果到 payload

        # 记录离开已完成的节点
        self._log_history(instance, WorkflowHistory.EventType.NODE_EXITED, node_id=completed_node_id, details=completion_data)

        # 更新当前节点 (移除刚完成的节点)
        current_nodes = list(instance.current_node_ids)
        if completed_node_id in current_nodes:
            current_nodes.remove(completed_node_id)

        next_node_ids_to_activate = []

        # 查找从已完成节点出发的边
        outgoing_edges = self._find_outgoing_edges(definition_json, completed_node_id)

        # 根据节点类型和边/条件确定下一个节点
        node_type = completed_node.get('type', '').lower()

        if node_type == 'decisionnode': # 或者你的决策节点类型
            evaluated_edge_found = False
            default_edge = None
            for edge in outgoing_edges:
                condition = edge.get('data', {}).get('condition', '') # 条件在边的 data.condition 中
                is_default = edge.get('data', {}).get('isDefault', False) # 检查是否有默认标记

                if not condition and not is_default: # 没有条件也不是默认，视为始终为真
                     target_node_id = edge.get('target')
                     next_node_ids_to_activate.append(target_node_id)
                     self._log_history(instance, WorkflowHistory.EventType.NODE_ENTERED, node_id=target_node_id, details={'来自决策节点': completed_node_id, '原因': '无条件路径'})
                     evaluated_edge_found = True
                     break # 假设是排他网关 (XOR)

                elif condition and rule_evaluator.evaluate(condition, instance.payload):
                     target_node_id = edge.get('target')
                     next_node_ids_to_activate.append(target_node_id)
                     self._log_history(instance, WorkflowHistory.EventType.NODE_ENTERED, node_id=target_node_id, details={'来自决策节点': completed_node_id, '满足条件': condition})
                     evaluated_edge_found = True
                     break # 假设是排他网关 (XOR)

                elif is_default:
                    default_edge = edge # 记下默认边，最后处理

            if not evaluated_edge_found and default_edge:
                 target_node_id = default_edge.get('target')
                 next_node_ids_to_activate.append(target_node_id)
                 self._log_history(instance, WorkflowHistory.EventType.NODE_ENTERED, node_id=target_node_id, details={'来自决策节点': completed_node_id, '原因': '默认路径'})
                 evaluated_edge_found = True

            if not evaluated_edge_found:
                 # 处理没有条件匹配且没有默认路径的情况 (例如，错误或流程卡住)
                 print(f"警告：决策节点 {completed_node_id} 在实例 {instance.id} 中没有路径满足条件且无默认路径")
                 # 可以在这里将实例标记为 FAILED 或 SUSPENDED
                 # instance.status = InstanceStatusModel.Status.SUSPENDED
                 # self._log_history(instance, WorkflowHistory.EventType.INSTANCE_FAILED, node_id=completed_node_id, details={'错误':'决策节点无匹配路径'})
                 pass # 当前实现：此路径停止

        elif node_type == 'endnode': # 或者你的结束节点类型
             # 工作流路径在此结束。如果没有其他活动路径，则完成实例。
             pass # 下面的逻辑处理实例完成检查

        else: # 标准节点类型 (开始、审批、服务、通知等)
             # 除非是并行拆分节点，否则假定只有一个传出路径
             for edge in outgoing_edges:
                 target_node_id = edge.get('target')
                 next_node_ids_to_activate.append(target_node_id)
                 self._log_history(instance, WorkflowHistory.EventType.NODE_ENTERED, node_id=target_node_id, details={'来自节点': completed_node_id})
                 # 如果是并行拆分 (AND)，添加所有目标。如果是顺序流，应该只有一条边。

        # 处理新激活的节点
        newly_activated_nodes_requiring_processing = []
        for next_node_id in next_node_ids_to_activate:
             if next_node_id not in current_nodes: # 避免在合并并行路径时重复添加
                 current_nodes.append(next_node_id)
                 newly_activated_nodes_requiring_processing.append(next_node_id)

        instance.current_node_ids = current_nodes # 先保存当前节点状态
        instance.save() # 保存 payload 和 current_node_ids 的更新

        # 现在处理需要动作的新节点（创建任务、执行服务等）
        # 将此移到循环外可以避免在一个事务中嵌套调用 advance_workflow
        for node_id_to_process in newly_activated_nodes_requiring_processing:
             next_node = self._find_node_by_id(definition_json, node_id_to_process)
             if not next_node:
                 print(f"错误：下一个节点 ID {node_id_to_process} 在定义中未找到。")
                 instance.status = InstanceStatusModel.Status.FAILED
                 instance.save() # 保存失败状态
                 self._log_history(instance, WorkflowHistory.EventType.INSTANCE_FAILED, details={'错误': f'下一个节点 {node_id_to_process} 未找到'})
                 # 停止此实例的进一步处理
                 continue # 处理下一个可能的新激活节点

             next_node_type = next_node.get('type', '').lower()

             # 为 *新进入* 的节点执行逻辑
             if next_node_type in ['approvalnode', 'usertasknode']: # 检查你的特定类型
                 self._create_task(instance, next_node)
                 # 路径在此暂停，等待任务完成

             elif next_node_type == 'servicetasknode':
                 # TODO: 执行服务任务 (例如，调用外部 API, 更新数据库)
                 # 这可能是同步的或异步的 (使用 Celery)
                 # 如果同步且成功，立即调用 advance_workflow(instance, node_id_to_process, {'service_result': ...})
                 # 如果异步，Celery 任务必须在完成时调用 advance_workflow
                 print(f"信息：到达服务任务 {node_id_to_process}。执行未实现。")
                 # 暂时假设同步成功：
                 # 注意：在同一个事务中递归调用 advance_workflow 可能导致问题，最好用 Celery
                 # self.advance_workflow(instance, node_id_to_process, {'service_result': 'NotImplemented'})
                 # 如果需要立即推进，并且操作很快，可以在这里直接调用，但要注意事务嵌套
                 # 更好的方式是让服务任务执行后（可能通过 Celery 任务）再调用 advance_workflow

             elif next_node_type == 'notificationnode':
                 # TODO: 发送通知 (例如，使用 Celery)
                 print(f"信息：到达通知任务 {node_id_to_process}。发送未实现。")
                 # 通知通常不阻塞，立即推进
                 # 同样，推荐异步处理后调用 advance_workflow
                 # self.advance_workflow(instance, node_id_to_process, {'notification_sent': 'NotImplemented'})

             elif next_node_type == 'endnode':
                 # 到达结束节点。此路径完成。
                 # 下面的逻辑将检查整个实例是否应完成。
                 pass # 此处无需操作

             elif next_node_type == 'decisionnode':
                  # 决策逻辑在 *离开* 节点时运行，所以只需进入即可。
                  # 或者，如果条件仅依赖于已存在的 payload，可以立即评估？
                  # 标准做法是根据传入数据/任务结果在退出时评估。
                  pass # 假设在退出时评估

             else: # 包括 'startNode' 或其他中间节点
                 # 没有特定操作，自动推进
                 self.advance_workflow(instance, node_id_to_process)


        # 在所有新节点处理（或任务创建）完成后，检查实例是否已完成
        # 重新获取实例状态，因为 advance_workflow 可能已被递归或异步调用修改
        instance.refresh_from_db()
        if not instance.current_node_ids and instance.status == InstanceStatusModel.Status.RUNNING: # 没有活动的节点意味着工作流完成
            instance.status = InstanceStatusModel.Status.COMPLETED
            instance.completed_at = timezone.now()
            instance.save()
            self._log_history(instance, WorkflowHistory.EventType.INSTANCE_COMPLETED)
            # TODO: 执行工作流完成时的任何最终操作 (例如，更新原始请假请求的状态)


    @transaction.atomic
    def complete_task(self, task_id, user, outcome, completion_data=None):
        try:
            # 使用 select_for_update 锁定任务和实例以防止竞争条件
            task = WorkflowTask.objects.select_for_update().select_related('instance').get(id=task_id)
            instance = WorkflowInstance.objects.select_for_update().get(id=task.instance.id)
            task.instance = instance # 确保任务关联的是锁定的实例
        except WorkflowTask.DoesNotExist:
            print(f"错误：任务 {task_id} 未找到。")
            raise ValueError(_("任务未找到")) # 返回可翻译的错误
        except WorkflowInstance.DoesNotExist:
             print(f"错误：任务 {task_id} 关联的实例 {task.instance_id} 未找到。")
             raise ValueError(_("任务关联的实例未找到"))

        # TODO: 添加权限检查：'user' 是否允许完成此任务？
        # (检查 task.assigned_users 或解析指派人标识符)
        # if not self._can_user_complete_task(user, task):
        #     raise PermissionError(_("用户无权完成此任务"))

        if task.status == TaskStatusModel.Status.COMPLETED:
            print(f"警告：任务 {task_id} 已完成。")
            # 可以选择返回任务或引发特定错误，表明重复完成
            # raise ValueError(_("任务已完成"))
            return task

        if task.status == TaskStatusModel.Status.CANCELED:
            print(f"警告：任务 {task_id} 已取消，无法完成。")
            raise ValueError(_("任务已取消"))


        task.status = TaskStatusModel.Status.COMPLETED
        task.outcome = outcome
        task.completion_data = completion_data or {}
        task.completed_at = timezone.now()
        task.completed_by = user
        task.save()

        # 将任务结果合并到实例 payload 中，以便后续节点（如决策节点）使用
        task_result_payload = {
            f"{task.node_id}_outcome": outcome,
            f"{task.node_id}_completion_data": task.completion_data,
            f"{task.node_id}_completed_by": user.username # 或 user.id
        }
        # instance.payload.update(task_result_payload) # advance_workflow 现在处理合并
        # instance.save() # advance_workflow 会保存

        self._log_history(
            instance,
            WorkflowHistory.EventType.TASK_COMPLETED,
            node_id=task.node_id,
            task=task,
            user=user,
            details={'结果': outcome, '完成数据': task.completion_data}
        )

        # 从生成此任务的节点推进工作流
        self.advance_workflow(instance, task.node_id, task_result_payload) # 将任务结果传递下去

        return task

# 实例化服务供视图使用
workflow_engine = WorkflowEngineService()
```

**III. Django REST Framework API (`serializers.py`, `views.py`, `urls.py`)**

```python
# workflows/serializers.py
from rest_framework import serializers
from django.utils.translation import gettext_lazy as _
from .models import WorkflowDefinition, WorkflowInstance, WorkflowTask, WorkflowHistory

class WorkflowDefinitionSerializer(serializers.ModelSerializer):
    class Meta:
        model = WorkflowDefinition
        fields = ('id', 'name', 'description', 'definition_json', 'version', 'is_active', 'created_at', 'updated_at')
        read_only_fields = ('id', 'version', 'created_at', 'updated_at') # 版本可能由内部管理

class WorkflowInstanceSerializer(serializers.ModelSerializer):
    definition_name = serializers.CharField(source='definition.name', read_only=True, label=_("定义名称"))
    definition_version = serializers.IntegerField(source='definition.version', read_only=True, label=_("定义版本"))
    status_display = serializers.CharField(source='get_status_display', read_only=True, label=_("状态显示"))

    class Meta:
        model = WorkflowInstance
        fields = ('id', 'definition', 'definition_name', 'definition_version', 'status', 'status_display', 'payload', 'current_node_ids', 'started_at', 'completed_at', 'content_type', 'object_id')
        read_only_fields = ('id', 'definition_name', 'definition_version', 'status', 'status_display', 'current_node_ids', 'started_at', 'completed_at')

class WorkflowTaskSerializer(serializers.ModelSerializer):
    instance_id = serializers.UUIDField(source='instance.id', read_only=True, label=_("实例ID"))
    status_display = serializers.CharField(source='get_status_display', read_only=True, label=_("状态显示"))
    assignee_type_display = serializers.CharField(source='get_assignee_type_display', read_only=True, label=_("指派类型显示"))
    # 可选择包含实例中的部分 payload 以提供上下文
    instance_payload_summary = serializers.SerializerMethodField(read_only=True, label=_("实例数据摘要"))

    class Meta:
        model = WorkflowTask
        # assigned_users 可能需要单独的 UserSerializer
        fields = ('id', 'instance_id', 'node_id', 'task_type', 'status', 'status_display', 'assignee_type', 'assignee_type_display', 'assignee_identifier', 'assigned_users', 'due_date', 'outcome', 'completion_data', 'created_at', 'completed_at', 'completed_by', 'instance_payload_summary')
        read_only_fields = ('id', 'instance_id', 'node_id', 'task_type', 'status', 'status_display', 'assignee_type', 'assignee_type_display', 'assignee_identifier', 'assigned_users', 'due_date', 'created_at', 'completed_at', 'completed_by', 'instance_payload_summary', 'outcome') # 结果通过完成动作设置

    def get_instance_payload_summary(self, obj):
        # 示例：为列表视图返回实例 payload 的子集
        payload = obj.instance.payload
        # 根据你的 payload 结构调整
        return {
            _('申请人'): payload.get('requester_name'),
            _('类型'): payload.get('leave_type'), # 假设是请假流程
            _('开始日期'): payload.get('start_date'),
        }

class WorkflowHistorySerializer(serializers.ModelSerializer):
    user_email = serializers.EmailField(source='user.email', read_only=True, allow_null=True, label=_("用户邮箱")) # 示例
    event_type_display = serializers.CharField(source='get_event_type_display', read_only=True, label=_("事件类型显示"))

    class Meta:
        model = WorkflowHistory
        fields = ('id', 'instance', 'node_id', 'task', 'event_type', 'event_type_display', 'timestamp', 'user', 'user_email', 'details')
        read_only_fields = '__all__'

# --- 特定动作的序列化器 ---
class StartWorkflowSerializer(serializers.Serializer):
    definition_id = serializers.UUIDField(required=True, label=_("工作流定义ID"))
    initial_payload = serializers.JSONField(required=True, label=_("初始数据负载"))
    # 可选：用于关联触发对象
    trigger_content_type_id = serializers.IntegerField(required=False, allow_null=True, label=_("触发对象内容类型ID"))
    trigger_object_id = serializers.UUIDField(required=False, allow_null=True, label=_("触发对象ID"))

class CompleteTaskSerializer(serializers.Serializer):
    outcome = serializers.CharField(required=True, max_length=100, label=_("任务结果")) # 例如 "approved", "rejected"
    completion_data = serializers.JSONField(required=False, default=dict, label=_("完成数据")) # 例如评论

```

```python
# workflows/views.py
from rest_framework import viewsets, status, mixins
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated, BasePermission # 添加更具体的权限
from django.contrib.contenttypes.models import ContentType
from django.shortcuts import get_object_or_404
from django.utils.translation import gettext as _
from django.db.models import Q
from django.contrib.auth import get_user_model

from .models import WorkflowDefinition, WorkflowInstance, WorkflowTask, WorkflowHistory
# 确保导入的模型常量有明确的来源
from .models import WorkflowTask as TaskStatusModel
from .models import WorkflowTask as AssigneeTypeModel
from .serializers import (
    WorkflowDefinitionSerializer, WorkflowInstanceSerializer, WorkflowTaskSerializer,
    WorkflowHistorySerializer, StartWorkflowSerializer, CompleteTaskSerializer
)
from .services import workflow_engine

# --- 权限类占位符 ---
class CanDesignWorkflows(BasePermission):
    def has_permission(self, request, view):
        # TODO: 实现检查用户是否有设计工作流的权限 (例如，属于特定组)
        return request.user and request.user.is_staff # 示例：仅允许 staff 用户

class CanManageInstances(BasePermission):
     def has_object_permission(self, request, view, obj):
        # TODO: 实现检查用户是否能管理特定实例的权限 (例如，管理员或特定角色)
        return request.user and request.user.is_staff

class CanCompleteTask(BasePermission):
    def has_object_permission(self, request, view, obj: WorkflowTask):
        # TODO: 实现检查用户是否是任务的合法处理人
        user = request.user
        if not user or not user.is_authenticated:
            return False
        # 1. 直接分配给用户
        if obj.assignee_type == AssigneeTypeModel.AssigneeType.USER and obj.assignee_identifier == str(user.id):
            return True
        # 2. 分配给用户所在的角色/组 (需要查询用户的角色)
        if obj.assignee_type == AssigneeTypeModel.AssigneeType.ROLE:
            user_roles = user.groups.values_list('name', flat=True) # 假设使用 Django groups
            if obj.assignee_identifier in user_roles:
                return True
        # 3. 规则指定 (例如，申请人经理 - 需要更复杂的逻辑来解析规则并检查用户是否匹配)
        if obj.assignee_type == AssigneeTypeModel.AssigneeType.RULE:
            # 这里需要调用类似 _resolve_assignees 的逻辑来判断 user 是否是该规则的解析结果之一
            # resolved_users = workflow_engine._resolve_assignees(obj.assignee_type, obj.assignee_identifier, obj.instance)
            # if user in resolved_users:
            #     return True
            pass # 规则解析需要具体实现
        # 4. 检查是否在 assigned_users M2M 字段中 (如果使用认领机制)
        if user in obj.assigned_users.all():
            return True

        print(f"权限检查：用户 {user.id} 不能完成任务 {obj.id} (指派: {obj.assignee_type}:{obj.assignee_identifier})")
        return False


class WorkflowDefinitionViewSet(viewsets.ModelViewSet):
    """
    管理工作流定义的 API 端点。
    """
    queryset = WorkflowDefinition.objects.all() # 提供所有版本，前端可按需过滤 active
    serializer_class = WorkflowDefinitionSerializer
    permission_classes = [IsAuthenticated, CanDesignWorkflows] # TODO: 限制给设计者/管理员

    # TODO: 添加用于激活/停用特定版本的操作

class WorkflowInstanceViewSet(mixins.ListModelMixin,
                              mixins.RetrieveModelMixin,
                              viewsets.GenericViewSet):
    """
    查看工作流实例和启动新实例的 API 端点。
    """
    queryset = WorkflowInstance.objects.all().select_related('definition')
    serializer_class = WorkflowInstanceSerializer
    permission_classes = [IsAuthenticated] # TODO: 基于用户参与情况的权限

    @action(detail=False, methods=['post'], serializer_class=StartWorkflowSerializer)
    def start_workflow(self, request):
        """
        启动一个新的工作流实例。
        """
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        data = serializer.validated_data

        triggered_by_object = None
        if data.get('trigger_content_type_id') and data.get('trigger_object_id'):
             try:
                 ct = ContentType.objects.get_for_id(data['trigger_content_type_id'])
                 # 确保模型存在
                 model_class = ct.model_class()
                 if model_class is None:
                      return Response({"error": _("无效的触发对象内容类型ID")}, status=status.HTTP_400_BAD_REQUEST)
                 triggered_by_object = model_class.objects.get(pk=data['trigger_object_id'])
             except ContentType.DoesNotExist:
                 return Response({"error": _("无效的触发对象内容类型ID")}, status=status.HTTP_400_BAD_REQUEST)
             except model_class.DoesNotExist:
                  return Response({"error": _("触发对象未找到")}, status=status.HTTP_400_BAD_REQUEST)

        try:
            instance = workflow_engine.start_instance(
                definition_id=data['definition_id'],
                initial_payload=data['initial_payload'],
                triggered_by_object=triggered_by_object,
                user=request.user
            )
        except WorkflowDefinition.DoesNotExist: # 捕获服务层可能抛出的错误
             return Response({"error": _("无法找到活动的工作流定义")}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
             print(f"启动工作流时发生意外错误: {e}")
             return Response({"error": _("启动工作流实例时发生内部错误。")}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


        if instance:
            # 使用主序列化器返回创建的实例数据
            instance_serializer = self.get_serializer(instance)
            return Response(instance_serializer.data, status=status.HTTP_201_CREATED)
        else:
            # start_instance 记录了错误，返回通用失败信息或特定错误
            return Response({"error": _("启动工作流实例失败。")}, status=status.HTTP_400_BAD_REQUEST)

    @action(detail=True, methods=['get'])
    def history(self, request, pk=None):
        """
        检索特定工作流实例的历史记录。
        """
        instance = self.get_object()
        # TODO: 添加权限检查，用户是否可以查看此实例的历史
        history = WorkflowHistory.objects.filter(instance=instance).select_related('user', 'task').order_by('timestamp')
        serializer = WorkflowHistorySerializer(history, many=True)
        return Response(serializer.data)

    # TODO: 添加取消、暂停、恢复实例的操作 (带权限检查)


class WorkflowTaskViewSet(mixins.ListModelMixin,
                          mixins.RetrieveModelMixin,
                          viewsets.GenericViewSet):
    """
    查看任务和完成任务的 API 端点。
    """
    queryset = WorkflowTask.objects.all().select_related('instance', 'completed_by', 'instance__definition')
    serializer_class = WorkflowTaskSerializer
    permission_classes = [IsAuthenticated] # 列表和检索也应该有权限控制

    def get_queryset(self):
        """
        根据登录用户过滤任务。
        用户应只能看到分配给他们或他们所属角色的任务。
        """
        user = self.request.user
        if not user.is_authenticated:
            return WorkflowTask.objects.none()

        # 实现基于用户 ID、用户角色/组匹配 task.assignee_identifier 和 task.assignee_type 的过滤。
        # 这比较复杂。
        # 简单的示例：直接分配给用户的任务 或 状态为 PENDING 且分配给用户所在角色的任务
        User = get_user_model()
        user_roles = user.groups.values_list('name', flat=True) # 示例：使用 Django groups 作为角色

        # Q 对象用于组合查询条件
        # 1. 直接分配给用户的任务
        user_q = Q(assignee_type=AssigneeTypeModel.AssigneeType.USER, assignee_identifier=str(user.id))
        # 2. 分配给用户所属角色且状态为待处理的任务 (已完成的不需要显示在待办列表)
        #    注意：如果角色任务需要认领，逻辑会更复杂
        role_q = Q(assignee_type=AssigneeTypeModel.AssigneeType.ROLE, assignee_identifier__in=list(user_roles), status=TaskStatusModel.Status.PENDING)
        # 3. 如果使用了 assigned_users M2M 字段（例如认领后），也需要包含
        assigned_q = Q(assigned_users=user)

        # TODO: 规则指派 (RULE) 的过滤需要调用服务来解析规则并判断用户是否匹配，这在查询时比较困难
        # 可能需要在服务层实现一个辅助函数来获取用户相关的任务 ID 列表

        # 组合查询
        # final_q = user_q | role_q | assigned_q
        # distinct() 避免重复
        # return super().get_queryset().filter(final_q).distinct()

        # --- 临时：返回所有任务用于演示 ---
        print("警告：WorkflowTaskViewSet 查询集过滤尚未完全针对用户权限实现。")
        qs = super().get_queryset()

        # 实现 ?status=pending 过滤
        status_filter = self.request.query_params.get('status')
        if status_filter:
            # 最好验证 status_filter 是否是合法的状态值
            valid_statuses = [choice[0] for choice in TaskStatusModel.Status.choices]
            if status_filter.upper() in valid_statuses:
                 qs = qs.filter(status=status_filter.upper())
            else:
                 # 或者返回空集，或者忽略无效过滤器
                 pass

        # 实现 ?assignee=me 过滤 (需要完善)
        assignee_filter = self.request.query_params.get('assignee')
        if assignee_filter == 'me':
             # 用上面构建的 final_q 替换这里的简单过滤
             print("警告：按 'assignee=me' 过滤未完全实现。")
             qs = qs.filter(Q(assignee_identifier=str(user.id)) | Q(assigned_users=user) | Q(assignee_type=AssigneeTypeModel.AssigneeType.ROLE, assignee_identifier__in=list(user_roles), status=TaskStatusModel.Status.PENDING)).distinct()

        return qs


    @action(detail=True, methods=['post'], serializer_class=CompleteTaskSerializer, permission_classes=[IsAuthenticated, CanCompleteTask])
    def complete(self, request, pk=None):
        """
        完成一个工作流任务 (例如，批准/驳回)。
        权限检查由 CanCompleteTask 处理。
        """
        task = self.get_object() # get_object 会处理 404 并应用权限检查
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        data = serializer.validated_data

        try:
            # 权限检查已由 permission_classes 处理
            completed_task = workflow_engine.complete_task(
                task_id=task.id,
                user=request.user,
                outcome=data['outcome'],
                completion_data=data.get('completion_data')
            )
            # 使用主序列化器返回更新后的任务数据
            task_serializer = self.serializer_class(completed_task)
            return Response(task_serializer.data, status=status.HTTP_200_OK)
        except ValueError as e: # 捕获服务层特定的业务逻辑错误
             return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)
        # PermissionError 应该由 DRF 的权限系统处理，返回 403
        # except PermissionError as e:
        #      return Response({"detail": str(e)}, status=status.HTTP_403_FORBIDDEN)
        except Exception as e: # 捕获意外错误
             print(f"错误：完成任务 {task.id} 时发生意外错误：{e}")
             # 生产环境中应记录详细错误日志
             return Response({"error": _("完成任务失败。")}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    # TODO: 如果需要基于角色的任务认领机制，添加 'claim' 操作。

# --- 设计器配置 API (简单示例) ---
from rest_framework.views import APIView

class WorkflowDesignerConfigView(APIView):
    """
    提供工作流设计器前端所需的配置信息。
    """
    permission_classes = [IsAuthenticated] # 允许所有登录用户查看配置？或者限制给设计者？

    def get(self, request, format=None):
        # TODO: 这个配置可以做得更动态，例如从数据库或配置文件加载
        config = {
            "nodeTypes": [
                {"type": "startNode", "label": _("开始事件"), "icon": "play-circle", "configSchema": {}},
                {"type": "endNode", "label": _("结束事件"), "icon": "stop-circle", "configSchema": {}},
                {
                    "type": "approvalNode",
                    "label": _("审批节点"),
                    "icon": "check-square",
                    "configSchema": {
                        # key: {label, type, options?, defaultValue?, helpText?}
                        "assigneeType": {"label": _("指派类型"), "type": "select", "options": [("USER", _("特定用户")), ("ROLE", _("角色/组")), ("RULE", _("规则指定"))], "defaultValue": "ROLE"},
                        "assigneeIdentifier": {"label": _("指派标识 (用户ID/角色名/规则)"), "type": "text"},
                        "taskName": {"label": _("任务名称模板"), "type": "text", "helpText": _("例如：审批 {payload.leave_type} 申请")},
                        # "timeoutDuration": {"label": _("超时 (秒, 0=无)"), "type": "number", "defaultValue": 0},
                        # "timeoutAction": {"label": _("超时动作"), "type": "select", "options": [("NOTIFY", _("提醒")), ("AUTO_REJECT", _("自动驳回")), ("AUTO_APPROVE", _("自动批准")), ("ESCALATE", _("上报"))]},
                    }
                },
                {
                    "type": "decisionNode",
                    "label": _("决策节点 (网关)"),
                    "icon": "gateway", # 使用更合适的图标名
                    "configSchema": {} # 条件通常在连接线上配置
                },
                {
                    "type": "notificationNode",
                    "label": _("通知节点"),
                    "icon": "bell",
                    "configSchema": {
                        "recipientType": {"label": _("接收人类型"), "type": "select", "options": [("USER", _("特定用户")), ("ROLE", _("角色/组")), ("REQUESTER", _("申请人"))], "defaultValue": "REQUESTER"},
                        "recipientIdentifier": {"label": _("接收人标识 (用户ID/角色名)"), "type": "text", "helpText": _("如果类型是申请人则无需填写")},
                        "messageTemplate": {"label": _("消息模板"), "type": "textarea", "helpText": _("可使用 {payload.field_name} 变量")},
                    }
                 },
                # 添加其他节点类型: ServiceTask, FormTask 等
            ],
            "edgeConfigSchema": { # 连接线的配置 (特别是从决策节点出来的线)
                "condition": {"label": _("流转条件"), "type": "textarea", "helpText": _("例如：payload.amount > 1000 或 payload.status == 'urgent' (为空则无条件)")},
                "isDefault": {"label": _("是否默认路径"), "type": "checkbox", "helpText": _("当决策节点其他条件都不满足时走此路径")}
            }
        }
        return Response(config)

```

```python
# workflows/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

# 创建一个 DRF 路由器
router = DefaultRouter()
# 注册视图集
router.register(r'definitions', views.WorkflowDefinitionViewSet, basename='workflowdefinition')
router.register(r'instances', views.WorkflowInstanceViewSet, basename='workflowinstance')
router.register(r'tasks', views.WorkflowTaskViewSet, basename='workflowtask')

# 应用的 URL 配置
urlpatterns = [
    # 包含路由器生成的 URL
    path('', include(router.urls)),
    # 设计器配置的单独 URL
    path('designer/config/', views.WorkflowDesignerConfigView.as_view(), name='workflow-designer-config'),
]
```

**IV. 集成与后续步骤**

1.  **Celery:** 集成 Celery & Celery Beat 用于:
    *   异步运行服务任务 (Service Tasks)。
    *   异步发送通知。
    *   根据 `due_date` 调度 `WorkflowTask` 的超时检查。
2.  **用户/组织集成:** 用你的实际逻辑替换占位符 `OrgChartService` 来查找经理和角色成员。
3.  **权限:** 实现更细粒度的权限 (例如，使用 `Django Guardian` 或自定义 DRF 权限类) 来控制谁能设计、启动、查看实例和完成任务。 `CanCompleteTask` 权限类需要仔细实现。
4.  **错误处理:** 增强 `WorkflowEngineService` 中的错误处理和日志记录。定义清晰的失败模式。
5.  **规则引擎:** 用健壮且安全的库替换基础的 `RuleEvaluator`。
6.  **触发:** 在你的 `LeaveRequest` 保存逻辑中 (例如，在 `save` 方法或 `post_save` 信号处理器中)，在成功保存后调用 `workflow_engine.start_instance`。
7.  **更新关联对象:** 在 `WorkflowEngineService` 中 (很可能是在到达 `endNode` 时)，实现更新 `triggered_by_object` (例如 `LeaveRequest`) 状态的逻辑。
8.  **Admin 后台:** 将模型注册到 Django Admin 以方便查看和管理。
9.  **测试:** 为模型、服务和 API 视图编写全面的测试。

这个更新后的版本将代码中的大部分英文注释和提示替换为了中文，使其更易于中文开发者理解。请注意，代码本身的逻辑和结构保持不变。